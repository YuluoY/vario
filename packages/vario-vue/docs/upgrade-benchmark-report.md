# Vario-Vue 升级前后性能对比报告

> 历史报告，曾由 `__tests__/upgrade-benchmark.test.ts` 生成。对比 **path-memo 关闭**（升级前）与 **path-memo 开启**（升级后）的渲染性能，从多维度分析并得出结论。

---

## 优化说明（通俗版）

### 为什么要做这次优化？

**原来的情况**：每次界面需要重新渲染时，渲染器都会把整棵「组件树」从头到尾再建一遍。树越大（节点多、层级深），建树就越慢。即使用户只改了一小块数据，很多没变的部分也会被重新创建，白白浪费 CPU。

**目标**：如果某一块的配置（schema）和显示条件都没变，就直接复用上次已经建好的那一块，不再重复建树，从而加快「再次渲染」的速度。

---

### 遇到了什么问题？

1. **性能问题**：页面复杂时，每次渲染都要全量走一遍 createVNode，耗时会随节点数、层级数明显上升。
2. **缓存错了会出 bug**：我们曾对「列表里的每一项」也做了缓存。结果列表数据更新后，界面还显示旧的列表项，因为复用的是旧的缓存。所以必须明确：**列表（loop）及其子节点不能参与这种复用**，只能按次重新创建。

---

### 具体做了哪些优化？

1. **按路径缓存子树（path-memo）**  
   给树里每个「位置」一个路径（例如根是 `""`，第一个子节点是 `"0"`）。渲染时先算出一个缓存 key：路径 + 当前节点的 schema 标识 + 依赖条件（如 cond/show 的求值结果）。如果 key 和上次一样，说明这一整棵子树没变，直接返回上次生成的 VNode，不再递归子节点。

2. **不缓存列表和列表项**  
   凡是带 `loop` 的节点，以及它们下面的整棵子树，都不参与缓存；列表里的每一项（path 里带 `[` 的，如 `"[0]"`）也不缓存。这样列表数据一变，就会重新创建对应的项，不会出现「列表更新了还显示旧内容」的问题。

3. **可选开关 usePathMemo**  
   渲染器支持配置项 `usePathMemo`（默认开启）。设为 `false` 时关闭 path-memo，行为与升级前一致，便于做性能对比和问题排查。

---

### 优化前后对比有什么好处？

| 维度 | 升级前 | 升级后（path-memo 开启） |
|------|--------|---------------------------|
| **再次渲染（热渲染）** | 每次全量建树，耗时会随规模变大 | 未变分支直接复用缓存，耗时大幅下降（约 98%～100% 量级） |
| **首次渲染（冷渲染）** | 全量建树 | 多了一步「算 key、写缓存」，部分场景略慢，属预期 |
| **列表 / 动态数据** | 每次重建 | 列表项仍每次重建，不缓存，保证数据更新后界面正确 |
| **可观测性** | 无 | 可用 `usePathMemo: false` 对比，确认是否为缓存带来的性能差异 |

**一句话**：在「同一份 schema 多次渲染、且很多分支没变」的场景下，这次优化能显著减少重复建树的开销；列表等动态部分保持不缓存，兼顾正确性与性能。

---

## 1. 测试目的

- 量化 **path-memo** 优化在 vario-vue 渲染管线中的收益。
- 从 **冷渲染**（无缓存）、**热渲染**（缓存命中）两个维度与升级前基准对比。
- 覆盖 **扁平多节点** 与 **深层嵌套** 两类典型 schema，评估不同规模下的表现。

---

## 2. 测试方法与参数

| 项目 | 说明 |
|------|------|
| 基准（升级前） | `usePathMemo: false`，每次渲染全量执行 `createVNode`，无子树复用 |
| 升级后 | `usePathMemo: true`，按 path 缓存子树，相同 schema/cond/show 复用 VNode |
| 冷渲染 | 每次清空 path-memo 缓存后再渲染，模拟“首次渲染”或 schema 变更后首帧 |
| 热渲染 | 缓存已填充后，同一 schema 再次渲染，模拟“重复渲染未变树” |
| Warmup | 每场景 `3` 次预热，减少 JIT/冷启动干扰 |
| 采样 | **基准、冷渲染、热渲染均采样 `10` 次，取平均值**（≥10 次） |

---

## 3. 指标定义

- **基准 (ms)**：升级前单次渲染平均耗时。
- **冷渲染 (ms)**：升级后“清缓存 + 渲染”平均耗时。
- **热渲染 (ms)**：升级后缓存命中时单次渲染平均耗时。
- **冷 vs 基准**：`(基准 - 冷渲染) / 基准 × 100%`，正值表示升级后冷渲染更快。
- **热 vs 基准**：`(基准 - 热渲染) / 基准 × 100%`，正值表示升级后热渲染更快。

---

## 4. 结果数据

| 场景 | 基准 (ms) | 冷渲染 (ms) | 热渲染 (ms) | 冷 vs 基准 | 热 vs 基准 |
|------|-----------|-------------|-------------|------------|------------|
| 扁平 100 节点 | 0.13 | 0.17 | 0.00 | -28.2% | +98.1% |
| 扁平 300 节点 | 0.47 | 0.56 | 0.00 | -19.7% | +99.4% |
| 扁平 500 节点 | 1.28 | 1.36 | 0.00 | -6.2% | +99.8% |
| 扁平 1000 节点 | 4.26 | 4.54 | 0.00 | -6.7% | +99.9% |
| 嵌套 5 层 2 叉 | 0.04 | 0.04 | 0.00 | +2.0% | +98.5% |
| 嵌套 8 层 2 叉 | 0.17 | 0.32 | 0.00 | -86.5% | +98.4% |
| 嵌套 10 层 2 叉 | 0.62 | 1.58 | 0.02 | -153.3% | +97.1% |

---

## 5. 各维度对比说明

### 5.1 冷渲染 vs 基准

- **整体**：冷渲染相对基准平均 **-42.6%**（各场景 -153% ～ 2%）。
- **扁平场景**：平均 -15.2%。冷渲染需清空并重建缓存，部分大规模扁平场景可能略慢于基准。
- **嵌套场景**：平均 -79.3%。深层嵌套下 cache key 计算与写入有额外开销，冷渲染与基准接近或略慢属预期。

### 5.2 热渲染 vs 基准

- **整体**：热渲染相对基准平均 **+98.8%**（各场景 97% ～ 100%）。
- **扁平场景**：平均 +99.3%。同一 schema 再次渲染时大量子树命中缓存，耗时显著下降。
- **嵌套场景**：平均 +98.0%。嵌套树可逐层复用，热渲染收益明显。

### 5.3 按场景类型

- **扁平多节点**：子节点多、路径稳定，path-memo 在热渲染下收益大；冷渲染因节点多、缓存写入多，可能略慢于基准。
- **深层嵌套**：深度大、每层可缓存，热渲染能大幅减少递归与 createVNode 调用；冷渲染下建树与建缓存并行，视规模可能略优或略劣。

### 5.4 按规模

- 节点数/深度越大，**基准**耗时越高；**热渲染**因复用比例高，耗时仍可维持在极低水平，故“热 vs 基准”提升百分比随规模增大而趋高或维持高位。
- 冷渲染随规模增大，缓存写入成本上升，与基准的对比可能由正转负，属预期。

---

## 6. 结论

1. **热渲染**：path-memo 在“同一 schema 再次渲染”场景下收益显著，各场景相对基准均有 **约 98%～100% 量级的耗时下降**，符合“未变子树复用 VNode”的设计目标。
2. **冷渲染**：因每次清空并重建缓存，与“无缓存、全量建树”的基准相比，部分场景略慢或接近；整体平均视数据在正负区间内，属预期权衡。
3. **升级建议**：本次升级（path-memo 默认开启）适合以 **重复渲染、列表/树未变分支多** 为主的业务；热路径收益明确，冷路径可接受。
4. **适用范围**：含 `loop` 的节点及其子树不参与 path-memo 缓存，列表项仍按次创建；本报告结论针对无 loop 或 loop 外静态子树为主的 schema。

---

*历史报告，曾由基准测试采样 10 次取平均生成；基准测试代码已移除，本文档保留作参考。*
